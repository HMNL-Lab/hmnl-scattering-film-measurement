% FUNCTION NAME:
%   imagej_csv_image_loader
%
% DESCRIPTION:
%   Compute the average of three inputs
%
% INPUT:
%   csv_path - (mustBeText) a path to the CSV file generated by the ImageJ plugin
%
% OUTPUT:
%   parameter_struct - (struct) struct with fields:
%       method_type: "ImageJ_Canny"
%       args:
%           reflection_image - (double) [width X height X color]
%           transmission_image - (double) [width X height X color]
%           reflection_image_path - (string) the local path to the reflection image
%           transmission_image_path - (string) the local path to the transmission image
%           nocorrection_reflection_pos1 - (double) [2   X 1]
%           nocorrection_reflection_pos2 - (double) [2 X 1]
%           reflection_pos1 - (double) [2 X 1]
%           reflection_pos2 - (double) [2 X 1]
%           transmission_pos1 - (double)
%           transmission_pos2 - (double)
%           angle_degree - (double)
%           conversion - (double)
%
% ASSUMPTIONS AND LIMITATIONS:
%   None
%
% REVISION HISTORY:
%   26/07/2022 - Noah McAllister
%       * Initial implementation
%

function [parameter_struct] = imagej_csv_image_loader(csv_path)
    arguments
        csv_path {mustBeText}
    end

    % Load csv into table
    csv_data = readtable(csv_path);

    % Specify method
    parameter_struct.method_type = "ImageJ_Canny";

    % Intialize images, check the files exist, and they are the same shape
    reflection_image_path = convertCharsToStrings(csv_data.Reflection);
    transmission_image_path = convertCharsToStrings(csv_data.Transmission);
    assert(isfile(reflection_image_path), "File at path to reflection image %s must exist.", reflection_image_path);
    assert(isfile(transmission_image_path), "File at path to transmission image %s must exist.", transmission_image_path);
    parameter_struct.args.reflection_image_path = reflection_image_path;
    parameter_struct.args.transmission_image_path = transmission_image_path;

    try
        reflection_image = imread(reflection_image_path);
    catch ME
        warning('Could not read reflection image at %s', reflection_image_path);
        rethrow(ME);
    end

    try
        transmission_image = imread(transmission_image_path);
    catch ME
        warning('Could not read transmission image at %s', transmission_image_path);
        rethrow(ME);
    end
    
    assert(isequal(size(reflection_image), size(transmission_image)), "Dimension mismatch: reflection and transmission images must be same size. \n Check that both have the same number of rows and cols, as well as that they are in the same colorspace.");
    
    % Initialize other parameters from CSV
    parameter_struct.args.angle = csv_data.Angle;
    parameter_struct.args.nocorrection_reflection_pos1 = [csv_data.x1_r; csv_data.y1_r];
    parameter_struct.args.nocorrection_reflection_pos2 = [csv_data.x1_r; csv_data.y1_r];
    
    % need to correct reflection angle
    parameter_struct.args.nocorrection_reflection_pos1 = [csv_data.x1_r; csv_data.y1_r];
    parameter_struct.args.nocorrection_reflection_pos2 = [csv_data.x1_r; csv_data.y1_r];

    parameter_struct.args.transmission_pos1 = [csv_data.x1_r; csv_data.y1_r];
    parameter_struct.args.transmission_pos2 = [csv_data.x1_r; csv_data.y1_r];



% 
% 
%     r_pos = [csv_data.x1_r; csv_data.y1_r];
%     t_pos = [csv_data.x1_t; csv_data.y1_t];
%     parameter_struct.pixelsPerMicron = csv_data.Conversion;
% 
%     % convert r_pos using rotation matrix
%     r_pos = [cosd(parameter_struct.angle), -sind(parameter_struct.angle); sind(parameter_struct.angle), cosd(parameter_struct.angle)] * r_pos;
%     parameter_struct.r.userSelectedX = round(r_pos(1));
%     parameter_struct.t.userSelectedX = round(t_pos(1));
%     % width = round(width/2)*2;
% 
%     % width is distance to search from outer to inner, with userSelectedX in
%     % the middle
%     % radius is the distance point to userSelectedX
%     parameter_struct.width = width;
%     parameter_struct.radius = round(parameter_struct.width/2);
% 
% 
%     % check if reflection and transmission are both color
%     if size(r_image.color, 3) ~= size(t_image.color, 3)
%         error("The color space of transmission and reflection images must be the same");
%     end
%     % take the difference between the reflection and transmission
%     diff.color = r_image.color - t_image.color;



end